## **1. Understand the Architecture**

The goal is to have:

1. **Game Engine (Runtime)** – Responsible for game logic, rendering, physics, audio, input, etc.
2. **Game Editor (Tool)** – A separate application to create/edit game levels, assets, entities, and components.
3. **Data-Driven Communication** – The editor saves scene data, and the engine loads it at runtime without editor dependency.

**Core Principles:**

* Engine and editor communicate through **assets and scene files** (e.g., JSON, YAML, or custom binary format).
* The editor should **not directly depend on the engine’s executable**—only on its **library/API**.
* Use **dynamic/shared libraries** (DLL/so) for hot-reloading the engine into the editor if desired.

---

## **2. Initial Setup**

### **Tools & Libraries**

* **C++17/20** for modern language features.
* **Raylib** for rendering.
* **Entt** for ECS (Entity Component System).
* **JSON/YAML/Flatbuffers** for scene serialization.
* **ImGui or rlImGui** for the editor UI.
* **CMake or Premake** for project structure.
* **Optional:** `dlopen`/`LoadLibrary` for hot code reloading.

### **Project Structure Example**

```
GameEngine/
 ├─ Engine/          # Core engine (rendering, ECS, input, physics)
 ├─ Editor/          # Level editor (uses engine as DLL or static lib)
 ├─ Game/            # Sample game project
 ├─ Assets/          # Models, textures, scenes
 ├─ CMakeLists.txt
```

---

## **3. Build the Core Engine**

Focus on **runtime first**:

1. **Window & Rendering** – Initialize raylib and render a simple sprite or cube.
2. **Game Loop** – Setup `while(!WindowShouldClose())` loop with delta time handling.
3. **ECS** – Integrate **Entt** for handling entities and components (Transform, Sprite, Collider, etc.).
4. **Scene Management** – Load and save a simple JSON scene with positions of objects.
5. **Basic Modules**:

   * Rendering System
   * Input System
   * Physics/Collision (optional at first)
   * Audio System

**Milestone 1:** You can load a scene file and render objects without any editor.

---

## **4. Create the Editor**

The editor should:

1. **Load & Save Scenes** – Open existing scenes or create new ones.
2. **Manipulate Entities** – Add/remove entities, attach components (Transform, Sprite, Camera).
3. **Visualize in Real-Time** – Use raylib or `rlImGui` to show the current scene.
4. **Inspector & Hierarchy Panels** – Like Unity or Godot editors.
5. **Export Scene Data** – Scene is saved in JSON/YAML for the engine to load at runtime.

**Milestone 2:** You can move entities in the editor, save the scene, and run the engine to see changes.

---

## **5. Separate Editor and Engine**

To make them **independent**:

* Compile the **engine as a static or shared library**.
* Editor **links to the engine library** for rendering and ECS usage.
* Game **loads scene files** generated by the editor without depending on the editor executable.

**Optional Advanced Step:**
Implement **hot-reloadable game logic** by loading game code as a DLL/so in the engine. This allows:

* Engine runs → Editor edits scene → Game updates live.

---

## **6. Advanced Features**

Once the basic loop is working:

1. **Component-Based Scripting** (Lua or C++ modules)
2. **Hot Code Reload** (Optional)
3. **Prefab & Asset Management**
4. **Physics Integration** (Box2D or Bullet)
5. **Build System for Game Projects** (Export standalone games)

---

## **7. Suggested Development Order**

1. Core Engine (Rendering + ECS + Scene Loading)
2. Editor with ImGui Panels
3. Scene Serialization
4. Asset Pipeline
5. Engine-Editor Separation via shared library
6. Optional: Scripting + Hot Reload

---